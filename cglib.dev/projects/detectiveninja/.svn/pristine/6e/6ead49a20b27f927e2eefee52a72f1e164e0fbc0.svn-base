#include "MyPhysics.h"

namespace proj {

	MyPhysics::MyPhysics() {
		_axesScale = 1.0;
		_position.set(0,0,0);
		_orientation.setRotationDeg(0,cg::Vector3d(0,1,0));
		_front.set(0,1,0);
		_up.set(0,0,1);
		_right.set(1,0,0);
		_linearVelocity = 0;
		_angularVelocity = 0;
		_isGoAhead = false;
		_isGoBack = false;
		_isYawLeft = false;
		_isYawRight = false;
		_isPitchUp = false;
		_isPitchDown = false;
		_isRollLeft = false;
		_isRollRight = false;
		_isJumping = false;

		_minHeight = 0.0;
		_maxHeight = 8.0;
		_currentHeight = 0.0;
		_boost = 5.0;
	}
	MyPhysics::~MyPhysics() {
	}
	cg::Vector3d MyPhysics::getPosition() {	return _position; }
	cg::Quaterniond MyPhysics::getOrientation() { return _orientation; }
	cg::Vector3d MyPhysics::getFront() { return _front; }
	cg::Vector3d MyPhysics::getUp() { return _up; }
	cg::Vector3d MyPhysics::getRight() { return _right; }

	void MyPhysics::setPosition(double x, double y, double z) {
		_position.set(x,y,z);
	}
	void MyPhysics::setLinearVelocity(double value) {
		_linearVelocity = value;
	}
	void MyPhysics::setAngularVelocity(double value) {
		_angularVelocity = value;
	}
	void MyPhysics::goAhead() { _isGoAhead = true; }
	void MyPhysics::goBack() { _isGoBack = true; }
	void MyPhysics::yawLeft() { _isYawLeft = true; }
	void MyPhysics::yawRight() { _isYawRight = true; }
	void MyPhysics::pitchUp() { _isPitchUp = true; }
	void MyPhysics::pitchDown() { _isPitchDown = true; }
	void MyPhysics::rollLeft() { _isRollLeft = true; }
	void MyPhysics::rollRight() { _isRollRight = true; }
	void MyPhysics::jump() { _isJumping = true; }
	void MyPhysics::doubleJump() { _isDoubleJumping = true; }

	bool MyPhysics::isJumping() {
		return _isJumping;
	}

	bool MyPhysics::isDoubleJumping() {
		return _isDoubleJumping;
	}

	inline
	void MyPhysics::rotate(double elapsed_seconds, int direction, 
						   cg::Vector3d axis, cg::Vector3d& v1, cg::Vector3d& v2) 
	{
		_q.setRotationDeg(direction * _angularVelocity * elapsed_seconds,axis);
		v1 = apply(_q,v1);
		v2 = apply(_q,v2);
		_orientation = _q * _orientation;
	}
	void MyPhysics::step(double elapsed_seconds) {
		if(_isGoAhead) {
			_position += _front * _linearVelocity * elapsed_seconds;
			_isGoAhead = false;
		}
		if(_isGoBack) {
			_position -= _front * _linearVelocity * elapsed_seconds;
			_isGoBack = false;
		}
		if(_isYawLeft) {
			rotate(elapsed_seconds,1,_up,_front,_right);
			_isYawLeft = false;
		}
		if(_isYawRight) {
			rotate(elapsed_seconds,-1,_up,_front,_right);
			_isYawRight = false;
		}
		if(_isPitchUp) {
			rotate(elapsed_seconds,1,_right,_up,_front);
			_isPitchUp = false;
		}
		if(_isPitchDown) {
			rotate(elapsed_seconds,-1,_right,_up,_front);
			_isPitchDown = false;
		}
		if(_isRollLeft) {
			rotate(elapsed_seconds,1,_front,_right,_up);
			_isRollLeft = false;
		}
		if(_isRollRight) {
			rotate(elapsed_seconds,-1,_front,_right,_up);
			_isRollRight = false;
		}
		if(_isJumping) {

			if (_isDoubleJumping) {
				_currentHeight = _position[2];
				_isJumping = false;
			}
			else {
				if (_isFalling) {
					_position -= _up * _linearVelocity * elapsed_seconds;

					if (_position[2] <= _minHeight) {
						_position[2] = _minHeight;
						_isJumping = _isFalling = false;
					}
				}
				else {
					_position += _up * _linearVelocity * elapsed_seconds;

					if (_position[2] >= _maxHeight) {
						_isFalling = true;
					}
				}
			}
		}
		if (_isDoubleJumping) {

			double maxHeight = _currentHeight + _boost;

			if (_isFalling) {
				_position -= _up * _linearVelocity * elapsed_seconds;

				if (_position[2] <= _minHeight) {
					_position[2] = _minHeight;
					_isDoubleJumping = _isFalling = false;
				}
			}
				else {
					_position += _up * _linearVelocity * elapsed_seconds;

					if (_position[2] >= maxHeight) {
						_isFalling = true;
					}
				}
		}

		_orientation.getGLMatrix(_rotationMatrix);
	}
	void MyPhysics::applyTransforms() {
        glTranslated(_position[0],_position[1],_position[2]);
		glMultMatrixd(_rotationMatrix);
	}
	void MyPhysics::setAxesScale(double scale) {
		_axesScale = scale;
	}
	void MyPhysics::drawAxes() {
		glPushMatrix();
			glTranslated(_position[0],_position[1],_position[2]);
			glScaled(_axesScale,_axesScale,_axesScale);
			glColor3f(1.0f,0.0f,0.0f);
			glBegin(GL_LINES);
				glVertex3f(0.0f,0.0f,0.0f);
				glVertex3d(_right[0],_right[1],_right[2]);
			glEnd();
			glColor3f(0.0f,1.0f,0.0f);
			glBegin(GL_LINES);
				glVertex3d(0.0,0.0,0.0);
				glVertex3d(_front[0],_front[1],_front[2]);
			glEnd();
			glColor3f(0.0f,0.0f,1.0f);
			glBegin(GL_LINES);
				glVertex3d(0.0,0.0,0.0);
				glVertex3d(_up[0],_up[1],_up[2]);
			glEnd();
		glPopMatrix();
	}
}